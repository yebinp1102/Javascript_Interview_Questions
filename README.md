<div align="center">
  <h2> [ 자바스크립트 면접 기출 문제 정리 ] </h2>
  <p style="color:gray">문제 클릭시 답변이 등장 합니다.</p>
</div>
<hr/>

<!-- 문제 1 -->
<details>
  <summary>
    1. 이벤트 위임(event delegation)이란?
  </summary>
  <br/>
  <div>
    이벤트 위임은 주로 비슷한 방식으로 여러 요소에 이벤트를 할당하거나 핸들링 할 때 사용 됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않는 대신 요소의 공통 조상에만 이벤트 핸들러를 할당해도 여러 요소들을 핸들링 할 수 있습니다. 여러 요소에 이벤트를 할당하게 되면 메모리 점유율이 높아져 페이지 성능이 낮아진다는 단점이 있는데, 이벤트 핸들링을 이벤트 위임으로 구현하게 되면 문제를 해소할 수 있다는 장점이 있습니다.
  </div>
</details>
<br/>
<!-- 문제 2 -->
<details>
  <summary>
    2. this 키워드에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    객체의 메서드는 자신이 속한 객체의 프로퍼티를 참조하고 변경할 수 있어야 하는데, 이때 this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다. 구체적으로 this란 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 이며, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정 됩니다. <br/><br/>
    1. 객체 리터럴로 생성된 객체의 내부 this : 메서드를 호출한 객체가 바인딩 됩니다. <br/><br/>
    2. 생성자 함수로 생성된 객체 내부 this : 생성자 함수가 생성할 인스턴스가 바인딩 됩니다. <br/><br/>
    3. 전역에서 this와 일반 함수 내부의 this에는 window가 디폴트로 바인딩 되며, use strict 모드에서는 undefined가 바인딩 됩니다. <br/><br/>
    4. Function.prototype.apply/call 메서드에 의한 간접 호출시 this : apply와 call 메서드의 본질적인 기능은 함수를 호출하면서 인수로 전달한 객체를 해당 함수의 this에 바인딩 하므로, this에는 메서드의 인수로 전달한 특정 객체가 바인딩 됩니다. <br/><br/>
    5. Function.prototype.bind 메서드에 의한 간접 호출시 this : bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달하기 때문에 this에는 인수로 전달한 객체가 바인딩 됩니다.
    <br/><br/>
    <p>요약</p>
    <table border="1">
      <tr bgcolor="salmon">
        <td>함수 호출 방식</td>
        <td>this 바인딩</td>
      </tr>
      <tr>
        <td>일반 함수 호출</td>
        <td>전역 객체 window</td>
      </tr>
      <tr>
        <td>메서드 호출</td>
        <td>메서드를 호출 한 객체</td>
      </tr>
      <tr>
        <td>생성자 함수 호출</td>
        <td>생성자 함수가 미래에 생성할 인스턴스</td>
      </tr>
      <tr>
        <td>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</td>
        <td>메서드의 첫번째 인수로 전달한 객체</td>
      </tr>
    </table>
  </div>
</details>
<br/>
<!-- 문제 3 -->
<details>
  <summary>
    3. prototype 기반 상속에 대해 설명하시요.
  </summary>
  <br/>
  <div>
    프로토타입은 프로토타입 객체라고도 불리며, 인스턴스를 포함한 어떤 객체의 부모 객체 역할을 하는 객체입니다. 자바스크립트에서 어떤 객체의 프로퍼티나 메서드를 다른 객체에 공유할 때, 프로토타입을 기반으로 상속을 구현하는 것이 개발 비용 측면에서 효율적입니다. 그 이유는 하나의 메서드를 다른 객체에 공유하는 두가지 방식을 비교하면 명확히 드러나는데요. 만약 생성자 함수 내부의 메서드를 생성될 인스턴스들이 갖게 되는 상황을 고려 했을 때, 프로토타입 기반 상속을 하지 않는 경우에는 인스턴스가 생성 될 때마다 생성자 함수의 메서드가 중복 생성되어, 같은 구조의 메서드가 메모리의 여러 공간을 차지하기 때문에 매우 비효율 적입니다. 반면 프로토타입을 기반으로 메서드를 상속하게 되면, 이러한 불필요한 중복을 제거 할 수 있는데요. 생성자 함수가 기본적으로 갖는 prototype이라는 프로퍼티에 어떤 메서드를 바인딩 하게 되면 해당 생성자 함수가 생성한 모든 인스턴스가 하나의 메서드를 공유해서 사용하기 떄문에 하나의 메모리 공간만 차지하게 됩니다. 
    <br/><br/>
    예시 코드와 함께 더 자세한 설명이 궁금하다면 제 블로그를 방문해주세요. <br/>
    <a href="https://blog.naver.com/yebinp1102/222886852128">블로그 링크 : https://blog.naver.com/yebinp1102/222886852128</a>
  </div>
</details>
<br/>
<!-- 문제 4 -->
<details>
  <summary>
    4. null과 undefined 그리고 undeclared에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    ◎ null은 변수에 값이 없다는 것을 <strong>"의도적으로 명시"</strong> 할 때 사용하는 자바스크립트의 데이터 타입 중 하나 입니다. 일반적으로 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하기 위해 사용하며, 변수에 null을 할당하게 되면 JS엔진은 아무도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행하기 됩니다.
    <br/>
    <br/>
    ◎ undefined는 JS 엔진이 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄지기 전까지 빈 상태로 두지 않기 위해 할당하는 초기 값 입니다. 이러한 이유로 var 키워드로 변수 선언 후 값을 할당 하지 않은 상태로 변수를 호출하면 undefined가 출력 됩니다. 
    <br/>
    <br/>
    ◎ undeclared는 접근 가능한 스코프에 변수 선언이 되지 않은 상태를 의미합니다. undeclared 상태의 변수를 참조 하게 되면 Uncaught ReferenceError 에러가 해당 함수가 정의 되지 않은 상태라는 메세지를 출력하게 됩니다.
  </div>
</details>
<br/>
<!-- 문제 5 -->
<details>
  <summary>
    5. 다음 코드가 즉시 호출 함수 표현식(IIFE)로 동작하지 않는 이유에 관해서 설명해보세요: function foo(){ }();.
  </summary>
  <br/>
  <div>
    즉시 실행 함수의 기본 형태는 그룹 연산자 (...)로 함수를 감싸고 있어야 하며, 함수의 코드 블럭 뒤에너느 함수 호출 연산자()가 있어야 한다. 하지만 위의 코드에서는 그룹 연산자로 감싸지 않았기 때문에 즉시 실행 함수로 동작하지 않는다. 더 구체적으로 이야기하자면 JS 엔진은 호출 연산자 ()를 함수와 분리된 그룹 연산자로 인식하기 때문에 function foo(){}; ()로 이해 하는 것이다. 이렇게 피연산자가 없는 그룹 연산자는 문법 에러를 발생시킨다. 만약 주어진 코드를 즉시 실행 함수로 동작하게 하고 싶다면, 아래와 같이 작성해야 한다. <br/>
    <code>(function foo(){ }())</code>
  </div>
</details>
<br/>
<!-- 문제 6 -->
<details>
  <summary>
    6. 익명함수(anonymous functions)는 주로 어떤 상황에서 사용하나요?
  </summary>
  <br/>
  <div>
    일반적으로 함수는 재사용을 위해 일단 선언 해두고 필요할 때마다 호출해서 쓰기 때문에 호출에 대비해 항상 메모리 공간의 일부를 차지합니다. 그런데 만약 어떤 함수가 한번만 사용된다면, 메모리 관리 측면에서 더 이상 필요없는 함수가 메모리 공간을 차지하는 것은 비효율적입니다. 이러한 경우에 사용하는 것이 바로 "익명 함수"인데요. 익명 함수는 자신이 호출 될때만 일시적으로 메모리 공간에 존재하다가 함수의 생명 주기가 끝나면 가비지 컬렉터에 의해 삭제되기 때문에 메모리 관리 측면에서 효율적입니다. 이러한 특징 때문에 익명 함수는 주로 state가 의도치 않게 변경되는 것을 방지하는 '클로져'나 '콜백 함수'로 사용 됩니다.
  </div>
</details>
<br/>
<!-- 문제 7 -->
<details>
  <summary>
    7. 클로져(Closure)는 무엇이며 왜 사용하나요?
  </summary>
  <br/>
  <div>
    외부 함수보다 중첩 함수의 생명 주기가 더 긴 경우에 중첩 함수가 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 때가 있는데, 이때 이 중첩 함수를 클로져라고 부른다. 예를 들어 전역에 선언된 inside라는 함수가 콘솔 창에 변수 x의 값을 출력하고, 전역에 선언된 outside 라는 함수가 변수 x의 값을 갖고 있고 inside 함수를 호출 한다고 가정해보자. 코드로 나타내면 아래와 같다.</br>
    <code>
      function outside(){</br>
      &nbsp const x = 10;</br>
      &nbsp inside()</br>
      }</br>
      function inside(){</br>
      &nbsp console.log(x)</br>
      }</br>
      outside()
    </code>
    <br/>
    이때 inside 함수가 클로져가 되는 것이다. 그 이유는 outside 함수가 호출 되면서 실행 컨텍스트에 push 되어 함수 코드 블럭의 코드를 하나씩 실행 하다가 마지막으로 inside 함수를 호출하면서 종료되기 때문에 실행 컨텍스트에서 pop 된다. 이는 outside 함수의 생명 주기가 종료 되었음을 의미하며, outside 함수의 생명 주기가 종료된 시점에 inside 함수가 실행 중이라면 inside 함수는 outside 함수보다 생명 주기도 길면서 상위 스코프에서 x 값을 참조하기 때문에 클로져가 되는 것이다.
    <br/>
    이러한 클로져는 주로 상태(state)가 의도하지 않은 방향으로 변경되는 것을 방지하기 위해 은닉하거나 특정 함수에게만 상태 변경을 허용하기 위해 사용된다.  
  </div>
</details>
<br/>
<!-- 문제 8 -->
<details>
  <summary>
    8. 아래 3개의 코드들의 차이점을 설명하시오.
    <br/><br/>
    <code>
      fucntion Person(){}; <br/>
      var person = Person(); <br/>
      var person = new Person(); <br/>
    </code>
  </summary>
  <br/>
  <div>
    먼저 <code>function Person(){};</code>은 일반 함수 선언문으로 실행을 하기 위해서는 호출을 해야만 한다. 반면 <code>var person = Person();</code>은 선언된 Person 함수를 호출하고, Person 함수가 반환하는 값을 person 변수에 할당한다. 그리고 <code>var person = new Person();</code>는 Person 생성자 함수가 만든 인스턴스를 person 변수에 할당한다. 참고로 Person 생성자 함수가 생성한 인스턴스는 Person 객체의 인스턴스를 상속 받는다. 
  </div>
</details>
<br/>
<!-- 문제 9 -->
<details>
  <summary>
    9. call과 apply 메서드의 차이는 무엇인가.
  </summary>
  <br/>
  <div>
    call과 apply 메서드가 공통적으로 하는 역할은 크게 2개이다. 첫번째는 첫번째 인수로 전달 받은 값을 함수의 this에 바인딩 하는 것이고, 두번째는 두번째 인수로 전달받은 데이터를 함수의 인수로 전달하면서 함수를 호출 하는 것이다. 함수 내부의 this에 특정 값을 명시적으로 바인딩 하면서 함수를 호출하며 동작 방식이 똑같지만 함수 호출 시 해당 함수에 인수를 전달하는 방식이 다르다. call 메서드는 함수 호출 시 전달할 인수들을 구분할 때 쉼표를 사용하지만, apply 메서드는 인수들을 하나의 배열로 묶어서 전달한다. <br><br>
    - 코드 예시<br>
    <code>
    function foo(a ,b, c){ <br>
    &nbsp console.log(‘’,arguments) <br>
    &nbsp return a+b+c; <br>
    } <br>
    let this = {a : 1} <br>
    foo.apply(this, [1, 2, 3]); <br>
    Foo.call(this, 1, 2, 3); 
    </code>
  </div>
</details>
<br/>
<!-- 문제 10 -->
<details>
  <summary>
    10. bind 메서드에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    bind 메서드도 call, apply 메서드와 this 바인딩을 위해서 사용되지만, 두 메서드와 달리 함수를 호출하지 않고 그저 인수로 받은 값을 해당 객체의 this에 바인딩한다. 이러한 bind 메서드는 주로 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 일치하지 않는 경우 통일 하기 위해 사용된다.
  </div>
</details>
<br/>
<!-- 문제 11 -->
<details>
  <summary>
    11. document.write()는 언제 사용하나요?
  </summary>
  <br/>
  <div>
    document 객체의 메서드인 write는 인수로 전달 받은 값을 웹 브라우저에 출력합니다. write 메서드는 웹 페이지 로딩 후 가장 먼저 인수로 전달받은 데이터를 브라우저에 출력하는데요. 이때 브라우저에 이미 로딜 된 데이터를 지우고 해당 데이터만 출력하므로 주로 디버깅이나 연산 결과를 확인 할 때 사용됩니다.
  </div>
</details>
<br/>
<!-- 문제 12 -->
<details>
  <summary>
    12. AJAX란 무엇인가요? AJAX의 장단점도 설명하시오.
  </summary>
  <br/>
  <div>
    AJAX란 자바스크립트로 브라우저가 서버에게 비동기 방식의 데이터를 요청하고, 서버가 응답한 데이터를 수신해서 동적으로 갱신하는 프로그래밍 방식입니다. AJAX는 브라우저가 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작하는데, 참고로 이 XMLHttpRequest 객체는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공합니다. AJAX의 장단점은 아래와 같습니다. <br><br>
    <장점><br>
    1. 브라우저의 일부만 변경해야 할 경우 필요한 데이터만 서버로부터 전송 받기 때문에 불필요한 데이터 통신이 발생하지 않는다. <br>
    2. 변경되지 않은 부분은 리렌더링 되지 않기 떄문에 화면 깜빡임 현상도 현저히 줄어든다. <br>
    3. 클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에 요청을 보내도 응답을 받을 때까지 다음 코드를 실행하지 않는 블로킹 현상이 발생하지 않는다.<br><br>
    <단점><br>
    1. XMLHttpRequest를 통해 통신 할 때, 사용자에게 아무런 정보를 주지 않는다.<br>
    2. AJAX를 지원하지 않는 브라우저가 존재한다.<br>
    3. 히스토리 관리가 어렵다.<br>
    4. 페이지 이동 없이 통신하기 때문에 보안에 취약하다.<br>
  </div>
</details>
<br/>
<!-- 문제 13 -->
<details>
  <summary>
    13. JSON은 어떻게 동작하나요?
  </summary>
  <br/>
  <div>
    JSON이란 클라이언트와 서버간의 HTTP 통신을 위해 주고 받는 데이터 형식으로 key와 value로 구성된 텍스트 데이터 포맷입니다. 만약 클라이언트 측에서 서버에게 어떤 데이터를 전송해야 한다면, JSON의 stringify 메서드를 사용해서 반드시 객체를 JSON 포맷의 문자열로 반환 해야 합니다. 반면 서버측에서 클라이언트에게 어떤 데이터를 전송할 경우에는 JSON의 parse 메서드를 사용해서 JSON 포맷의 문자열을 객체화 해야 합니다.
  </div>
</details>
<br/>
<!-- 문제 14 -->
<details>
  <summary>
    14. JSON과 AJAX는 어떻게 다른가?
  </summary>
  <br/>
  <div>
    JSON은 클라이언트와 서버가 통신을 위해 주고 받는 데이터의 포맷 형식입니다. 이와 달리 AJAX는 클라이언트와 서버가 통신해서 XMLHttpRequest 객체를 이용해서 브라우저의 일부만 리렌더링 하기 위한 비동기 통신 방법입니다. 
  </div>
</details>
<br/>
<!-- 문제 15 -->
<details>
  <summary>
    15. 호이스팅이란? (변수 호이스팅과 함수 호이스팅의 차이)
  </summary>
  <br/>
  <div>
    JS엔진은 런타임 이전에 모든 선언문을 먼저 실행합니다. 때문에 선언문 이전에 함수나 var 키워드로 선언된 변수가 참조 가능합니다. 이렇게 코드가 마치 선두에 있는 것처럼 동작하는 자바스크립트 고유의 특징이 바로 호이스팅 입니다. 참고로 변수 호이스팅과 함수 호이스팅은 조금 다르게 동작합니다. var 키워드로 선언된 변수는 변수 선언문 이전에 참조하게 되면 undefined로 평가되는 반면, 함수 선언문 이전에 함수를 참조하게 되면 멀쩡하게 호출 됩니다. 그 이유는 var 키워드로 선언된 변수의 경우 런타임 이전에 식별자에 undefined가 할당 되는 반면 함수 선언문으로 선언된 변수의 경우 런타임 이전에 함수 객체가 생성되고, JS엔진이 함수명과 동일한 식별자를 암묵적으로 생성해서 생성된 함수 객체를 그 식별자에 할당합니다. 이러한 이유로 함수 선언문 이전에 함수 호출이 가능한 것입니다. 
  </div>
</details>
<br/>
<!-- 문제 16 -->
<details>
  <summary>
    16. 이벤트 버블링이란?
  </summary>
  <br/>
  <div>
    어떤 DOM 요소 노드에서 이벤트가 발생하면, 이 요소에 할당된 이벤트 핸들러가 동작한다. 그 후 이어서 부모 요소 노드의 이벤트 핸들러가 수행되고, 이후 부모의 부모 요소의 이벤트 핸들러가 수행 된다. 이러한 과정은 최상단의 요소 노드에 도달 할 때까지 반복되며, 이렇게 이벤트 핸들러가 상위 요소로 전파되는 현상을 이벤트 버블링이라고 한다. 예를 들어 form 태그 내부에 div 태그가 있고, div 태그 내부에 p태그가 있으며, 각 태그를 클릭할 경우 alert 창에 어떤 태그에서 이벤트가 발생 했는지 알리는 코드가 있다고 가정해보자. 만약 가장 하위에 있는 p태그를 클릭하면 alert 창에는 p가 출력된다. 그리고 alert 창을 닫으면 곧바로 또 다른 alert 창에 div가 출력되고, 다시 창을 끄면 form을 출력하는 alert태그가 출력된다.
  </div>
</details>
<br/>
<!-- 문제 17 -->
<details>
  <summary>
    17. 이벤트 캡쳐링이란?
  </summary>
  <br/>
  <div>
    이벤트 버블링과 반대로 어떤 태그에 이벤트 발생 시 이벤트 핸들러가 하위 요소로 전파되는 현상.
  </div>
</details>
<br/>
<!-- 문제 18 -->
<details>
  <summary>
    18. 속성(attribute)과 요소(element)의 차이는?
  </summary>
  <br/>
  <div>
    요소란 HTML 문서를 구성하는 각 태그를 의미하며, 속성이란 이러한 요소들의 동작을 제어하기 위한 추가 정보를 제공 합니다. 예를 들어 a 태그에 클릭시 이동할 주소를 가리키는 href 값이 있을 때, 요소는 a이며 href는 속성입니다.
  </div>
</details>
<br/>
<!-- 문제 19 -->
<details>
  <summary>
    19. 비교 연산자 ==와 ===의 차이는?
  </summary>
  <br/>
  <div>
    동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 암묵적으로 타입을 일치 시킨 후 같은 값인 지 판별합니다. 반면 일치 비교 연산자(===)는 좌항광 우항의 피연산자가 타입도 일치하고 값도 일치하는 경우에만 true를 반환합니다.
  </div>
</details>
<br/>
<!-- 문제 20 -->
<details>
  <summary>
    20. duplicate([1,2,3,4,5])의 결과가 [1,2,3,4,5,1,2,3,4,5]가 되도록 코드를 작성하시오.
  </summary>
  <br/>
  <code>
    function duplicate(arr){<br>
      return [...arr, ...arr]<br>
    }
  </code>
</details>
<br/>
<!-- 문제 21 -->
<details>
  <summary>
    21. 삼항식을 사용하는 이유는 무엇이며 어떻게 사용하나요?
  </summary>
  <br/>
  <div>
    삼항식은 조건식의 평가 결과에 따라 반환 값을 결정하는 문입니다. 삼항식은 총 3개의 피연산자를 갖는데요. 첫번째 피연산자는 조건식으로 true나 false로 평가되며, true로 평가될 경우 두번째 피연산자를 반환하는 반면 false로 평가될 경우 세번째 피연산자를 반환합니다. if...else문과 비교 했을 때, if...else문은 표현식이 아니기 때문에 반환 값을 값처럼 사용할 수 없는 반면, 삼항식은 값으로 평가 가능한 표현식인 문이기 때문에 반환 값을 값으로 사용 가능합니다. 이러한 특징 때문에 조건이 1개이며 조건에 따라 결정되는 값을 변수에 할당 하고 싶은 경우에 if...else문 보다 삼항식을 사용하는 것이 훨씬 유리합니다. 
  </div>
</details>
<br/>
<!-- 문제 22 -->
<details>
  <summary>
    22. use strict란 무엇인가요?
  </summary>
  <br/>
  <div>
    use strict는 자바스크립트에서 허용하는 애매한 문법을 모두 오류라고 인식하기 때문에 프로그래밍의 흐릅에 더 적합하고 정확한 코드를 작성하기 위해 사용됩니다. use strict를 사용하려면 적용하려는 스코프의 최상단에 작성하면 됩니다. 만약 use strict가 선언되지 않은 상태에서 함수 선언 키워드(var, let, cont) 없이 선언된 변수를 참조 할 경우, JS엔진이 암묵적으로 변수 선언문으로 인식하기 때문에 변수 참조가 가능하다. 하지만 엄격하게 문법적으로 그리고 프로그래밍의 흐름에 부적합하다. 이러한 문제를 해결 하기 위해 해당 변수의 스코프 최상단에 use strict를 작성하면 정석으로 선언되지 않은 변수 참조시 에러가 발생하기 된다. 이렇게 use strict를 사용할 경우 안전한 코드 작성이 가능하고 JS 엔진이 자동으로 최적화하여 연산을 수행하기 때문에 수행 속도가 더 빨라진다는 장점이 있다. 

  </div>
</details>
<br/>
<!-- 문제 23 -->
<details>
  <summary>
    23. 전역 스코프(scope)의 장단점은 무엇인가요?
  </summary>
  <br/>
  <div>
    전역 스코프에 선언된 변수나 함수는 하위의 어떤 스코프에서든 접근 가능하다는 장점이 있다. 하지만 모든 스코프에서 접근 가능하기 때문에 의도하지 않은 값 변경이 발생 할 수 있으며, 이러한 문제가 발생할 경우 어느 스코프에서 값을 변경 했는지 추적하기 어려울 수 있다. 또한 전역 스코프에 선언된 변수와 함수의 생명 주기는 어플리케이션이 실행되는 순간부터 종료되는 순간이기 때문에 더이상 참조 되지 않는 변수 혹은 함수라 해도 메모리 공간을 계속해서 차지하기 때문에 메모리 낭비로 이어진다. 이외에도 변수명 중복 가능성과 스코프의 depth가 깊어질수록 전역에 선언된 변수를 검색하는 속도가 느려진다는 단점이 있기 때문에 전역에 변수를 선언할 때, 반드시 전역에 선언되지 않으면 안되는 변수인지 확인하고 그렇지 않은 경우 지역 변수로 선언하는 것이 올바르다. 
  </div>
</details>
<br/>
<!-- 문제 24 -->
<details>
  <summary>
    24. SPA에서 SEO에 유리해지려면 어떻게 해야 하나요?
  </summary>
  <br/>
  <div>
    SPA는 기본적으로 CSR 방식으로 구현되기 때문에 SEO에 불리 할 수 밖에 없다. SPA는 클라이언트가 여러 페이지를 하나의 페이지에 구현하기 때문에 JS를 읽지 못하는 검색 엔진은 해당 페이지의 HTML 문서에서 중요한 데이터들을 추출하지 못한다. 즉 크롤링에 불리하다. 이러한 문제를 해결하기 위한 방법은 크게 3가지로 나뉜다. 첫번째는 CSR 대신 SSR을 채택하는 것이고, 두번째는 동적 렌더링을 사용하는 것이며, 세번째는 History API를 사용하는 것이다. 동적 렌더링이란 SSR 사용이 불가피한 경우 주로 사용하는 방식으로 서버에서 요청하는 자가 사람인지 크롤러인지 판단 후, 사람이면 HTML과 JS 문서를 제공하고 크롤러이면 렌더링된 HTML 버전의 페이지를 제공해서 크롤링 가능하게 하는 방법이다. History API는 SPA 어플리케이션의 한 페이지에서 일부 컨텐츠만 변경될 경우 url 변경이 없어 크롤링이 되지 않는 문제 해결을 위해 일부 컨텐츠 변경시 url이 변경되도록 하는 방법이다.
  </div>
</details>
<br/>
<!-- 문제 25 -->
<details>
  <summary>
    25. function foo() {}와 var foo = function() {}에서 foo 의 차이가 무엇인지 설명해보세요.
  </summary>
  <br/>
  <div>
    <code>function foo(){}</code>에서 foo는 함수 선언문으로 선언된 함수 foo이고 <code>var foo = function (){}</code>에서 foo는 함수 리터럴을 할당 받는 변수 foo이다. 즉 함수 선언문이냐 함수 표현문이냐의 차이인데, 둘은 동작 방식이 다르다. 함수 선언문은 함수 호이스팅에 의해 따르기 때문에 함수 선언문 이전에 함수를 호출해도 동작하는 반면, 함수 표현문은 변수 호이스팅을 따르기 때문에 함수 표현문 이전에 foo를 호출 할 경우 초기화 단계에서 할당된 undefined가 호출되며, undefined는 함수가 아니기 때문에 TypeError가 발생한다. 
  </div>
</details>
<br/>
<!-- 문제 26 -->
<details>
  <summary>
    26. 객체 안의 속성과 배열의 아이템을 순회할 때 사용하는 문법에 관해 설명해주세요.
  </summary>
  <br/>
  <div>
    객체의 속성과 배열을 순회하는 방법은 크게 2가지로 나뉜다. 첫번째는 for문을 사용하는 것으로 배열의 경우 배열의 0번 인덱스부터 배열의 length 인덱스 까지 순회하면 된다. 객체는 배열과 달리 length 조회가 안된다. 따라서 객체 생성자 Object의 메서드인 keys를 사용해서 객체의 모든 key 값을 배열로 출력 받은 다음, 배열의 길이 만큼 for문으로 순회하면 된다. 그리고 두번째 방법은 for...of문 와 for...in문을 사용하는 것이다. 배열을 순회할 때는 for...of문을 사용해서 배열의 각 요소에 한번씩 접근 가능하며, 객체를 순회할 때는 for...in문을 사용해서 각 key 값에 한번씩 접근 가능하다. 
  </div>
</details>
<br/>
<!-- 문제 27 -->
<details>
  <summary>
    27. 동기 방식과 비동기 방식의 차이에 관해서 설명해주세요.
  </summary>
  <br/>
  <div>
    JS엔진은 한번에 하나의 테스크만 수행하는 싱글 스레드 방식으로 동작한다. 일반적으로 하나의 테스크를 수행하기 시작하면 수행을 완전히 종료할 때까지 기다렸다가 다음 테스크를 실행하는데, 이를 "동기 처리"라고 한다. 코드를 동기 처리 할 경우, 코드의 흐름이 직관적이기 때문에 예측 가능하다는 장점이 있지만, 어떤 테스크의 수행 시간이 매우 길 경우 다음 테스크가 기약없이 기다려야 한다는 단점이 있다. 예를 들어, 어떤 함수가 서버에게 홈페이지에 관한 모든 리소스(HTML, CSS, JS, 이미지 등)를 요청하고, 서버의 응답은 약 5초 걸린다고 가정해보자. 서버에게 요청이 들어간 순간부터 사용자는 약 5초간 아무런 변화 없는 홈페이지를 보고 있어야 하는데, 이는 사용자 측면에서 나쁜 UX이다. 이러한 문제를 해결하기 위한 방안이 바로 "비동기 처리"이다. 비동기 처리란 실행 중인 테스크가 완전히 종료되지 않아도 다음 연산을 수행하는 것을 의미한다. 예를 들어, 서버에게 어떤 데이터를 요청했고, 요청에 대한 응답은 5초 정도 걸린다고 가정 했을 때, 비동기 처리를 하게 되면 서버로부터 응답을 받는데 걸리는 시간인 5초를 기다리지 않고 다른 테스크를 먼저 수행하다가 응답이 도착하면 그때 테스크 수행을 완수하는 것이다. 이렇게 필요에 따라 비동기 처리를 하게 되면 동기 처리를 할 때보다 우수한 UX를 만들 수 있으나 코드의 흐름을 예측하기 어렵다는 단점이 있으니 남발해서는 안된다. 
  </div>
</details>
<br/>
<!-- 문제 28 -->
<details>
  <summary>
    28. var, let, const의 차이점에 관해서 설명해주세요.
  </summary>
  <br/>
  <div>
    <strong>var 키워드로 선언된 변수의 특징 : </strong><br>
    - 변수 중복 선언 가능<br>
    - 함수 레벨 스코프 : 함수의 코드 블럭만 지역 스코프로 인정한다.<br>
    - 런타임 이전에 선언 단계와 초기화 단계가 수행된다. 변수 선언문 이전에 변수 참조시 undefined 반환<br><br>
    <strong>let 키워드로 선언된 변수의 특징 : </strong><br>
    - 변수 중복 선언 불가<br>
    - 블록 레벨 스코프 : 모든 코드 블럭을 지역 스코프로 인정 한다.<br>
    - 런타임 이전에 선언 단계를 실행되지만 초기화 단계는 런타임에 실행되기 때문에 선언문 이전에 변수 참조시 참조 에러가 발생한다.<br><br>
    <strong>const 키워드로 선언된 변수의 특징 :</strong><br>
    - let 키워드로 선언한 변수의 특징을 모두 가짐<br>
    - 추가로 선언 시 반드시 값을 할당해야 함<br>
    - 재할당이 금지된다.(원시 값은 한번 할당하면 불변하지만, 객체는 값 변경이 가능하다. 재할당 !== 불변)
  </div>
</details>
<br/>
<!-- 문제 29 -->
<details>
  <summary>
    29. event loop, call stack, task queue에 관해 설명해주세요.
  </summary>
  <br/>
  <div>
    <strong>evnet loop</strong> : 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다. 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 FIFO 방식으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다. 이때 콜 스택으로 이동한 함수는 실행되며 태스크 큐에 임시 보관된 함수들은 비동기 처리 방식으로 동작한다.<br><br>
    <strong>call stack</strong> : 소스 코드(전역 코드나 함수 코드 등) 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조로 '실행 컨텍스트 스택'이라고도 불린다. 함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 push 되어 실행된다. JS엔진은 하나의 콜 스택만 갖기 때문에 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 태스크는 실행되지 않는다.<br><br>
    <strong>task queue</strong> : setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다. 태스크 큐는 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 전재한다. 
  </div>
</details>
<br/>
<!-- 문제 30 -->
<details>
  <summary>
    30. 다음 코드가 예상과 달리 동작하는 이를 설명하고, 코드를 수정하세요.<br><br>
    <code>
      let str = 'string'<br/>
      str[0] = 'S'<br/>
      console.log(str) // 'string' 대문자로 변경되지 않았음
    </code>
  </summary>
  <br/>
  <div>
    변수 str에 할당된 'string'은 문자열 타입의 데이터로 원시 타입이기도 하다. 이러한 원시 타입의 데이터는 불변성이라는 특성을 갖기 때문에 데이터의 일부만 변경하는 것이 불가능하다. 따라서 변수 str에 'String'(첫글자 대문자)를 할당하고 싶다면, 기존 'string'을 수정하는 것이 아니라 'String'이라는 새로운 문자열을 재할당 해야 한다. 더 구체적으로 설명하자면, 식별자 str가 가리키는 메모리 공간에는 'string'이라는 값이 저장되어 있고 문자열은 원시 타입이기 때문에 일부 변경이 불가능 하니 'String'이라는 새로운 문자열을 메모리 공간 어딘가에 저장해놓고 식별자 str이 새로운 문자열이 할당된 메모리 공간을 가리키도록 재할당하는 것이다. 만약 위의 코드와 같이 어떤 문자열의 첫번째 알파벳을 대문자로 표현하고 싶다면 아래와 같이 코드를 작성하면 된다. <br/>
  </div>
  <code>
    let str = 'string'; <br/>
    str = str.charAt(0).toUpperCase() + str.slice(1) <br>
  </code>
</details>
<br/>
<!-- 문제 31 -->
<details>
  <summary>
    31. 참조에 의한 전달과 값에 의한 전달의 의미는 무엇이며 두 개념의 차이를 설명해보세요.
  </summary>
  <br/>
  <div>
    만약 변수 A에 객체 a를 할당한 후 변수 B에 변수 A를 할당하게 될 경우 변수 A와 B는 '참조에 의해 값을 전달' 받는다. 객체는 원시 타입의 데이터와 달리 변수에 할당할 때, 원본 객체를 식별자에 그대로 할당하는 것이 아니라 메모리 어딘가에 저장된 객체의 주소를 알려주는 참조값을 변수에 할당한다. 따라서 해당 변수를 참조하게 되면 변수에 할당된 참조값으로 객체에 접근할 수 있게 된다. 이렇게 참조에 의한 값을 전달 할 때 주의해야 할 점은 런타임 도중 객체의 일부 프로퍼티가 변경, 삭제, 추가 될 경우 해당 참조값을 할당 받는 모든 변수도 변경된 객체를 참조하게 된다. 번외로 객체를 갖는 변수를 또 다른 변수에 할당하는 것을 '얕은 복사'라고 부른다. 아래는 얕은 복사 그리고 참조에 의한 전달의 코드 예시이다. <br><br/>
  </div>
  <code>
    let person = {<br>
    &nbsp;  name: 'Lee';<br>
    }<br>
    let copy = person;<br>
    copy.name = 'Kim'<br>
    console.log(copy) // {name: 'Kim'}<br>
    console.log(person) // {name: 'Kim'}<br>
  </code>
  <br/>
  <div>
    참조에 의한 전달이 특정 참조 값을 참조하는 모든 변수가 원본 값을 공유하는 것이었다면, 값에 의한 참조는 반대로 같은 값이라도 다른 메모리 공간에 저장해둠으로써 서로 영향을 받지 않는 것이다. 예를 들어 변수 A에 숫자 100을 할당하고, 변수 B에 변수 A를 할당하면 변수 A,B 모두 100이라는 값을 갖는데, 이때 하나의 메모리 공간에 존재하는 100을 공유하는 것이 아니라 두 메모리 공간에 저장된 100을 독립적으로 참조하고 있는 것이다. 이는 깊은 복사라고도 불리며, 이러한 특징 때문에 아래의 코드에서 score과 copy 변수는 다른 값을 갖게 된다.
  <div>
  <br>
  <code>
    let score = 100;<br>
    let copy = score;<br>
    score = 50;<br>
    console.log(score, copy); // 50, 100<br>
  </code>
</details>
<br/>

<!-- 문제 32 -->
<details>
  <summary>
    32. 비동기 처리 시 Promise의 Callback 함수 대비 장점은 무엇인가요?
  </summary>
  <br/>
  <div>
    콜백 함수로 비동기 처리를 할 경우 마주하게 될 문제점은 크게 2가지가 있다. 첫번째는 콜백 헬인데, 비동기 처리 결과에 대한 후속 처리를 할 때 콜백 함수에 또 다시 콜백 함수를 작성해야 하기 때문에 후속 처리가 늘어날 수록 함수의 중첩이 심화되면서 가독성이 매우 저하되는 현상이다. 그리고 두번째 문제점은 에러 처리의 한계이다. 에러는 호출자 방향으로 전달 되는데, 콜백 함수의 실행 시점은 호출자가 이미 콜 스택에서 pop 된 후이기 때문에 try...catch문으로도 에러를 캐치할 수 없는 현상이다. 이러한 문제점들은 ES6에서 등장한 Promise를 대신 사용하면 완화할 수 있다. Promise는 후속 처리 메서드 then, catch, finally를 갖는데, 이 후속 처리 메서드를 사용하면 비동기 처리 상태의 변화에 따라 후속 처리 메서드의 콜백 함수가 조건적으로 호출 된다. 즉, 콜백 내부에 콜백을 작성하지 않기 때문에 가독성을 저하하는 콜백 지옥 문제를 해결할 수 있으며, catch 메서드를 통해 에러를 캐치 할 수도 있다. 더 나아가 catch 메서드를 then 메서드 이후에 호출할 경우 비동기 처리에서 발생한 에러뿐 아니라 then 메서드 내부에서 발생한 에러도 캐치한다는 큰 장점이 있다.
  </div>
</details>
<br/>

<!-- 번외 1. 용어 정리 -->
<details>
  <summary>
    번외 1) 용어 정리
  </summary>
  <br/>
  <div>
    <ul>
      <li><strong>변수</strong> : 하나의 값을 저장하기 위해 확보된 메모리 공간을 식별하기 위한 이름</li>
      <li><strong>리터럴</strong> : 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법</li>
      <li><strong>런타임</strong> : JS엔진이 코드를 실행하는 시점</li>
      <li><strong>표현식</strong> : 값으로 평가 될 수 있는 문. 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.<br/>
        <code>let score = 50 + 50; // 리터럴(50)과 연산자(+)를 평가해서 100을 생성하기 때문에 표현식이다  </code><br/>
        <code>let score2; // 변수 선언문은 값을 평가하지 않으니 표현식이 아니다.</code> <br/>
        <code>score; // 변수 score를 참조 했을 때 100이란 값을 평가하니 표현식이다.</code>
      </li>
      <li><strong>평가</strong> :표현식을 해석해서 값을 생성하거나 참조하는 것</li>
      <li><strong>값</strong> : 표현식이 평가되어 생성된 결과</li>
      <li><strong>문</strong> : 프로그램을 구성하는 기본 단위이자 최소 실행 단위. 여러 토큰으로 구성된다.</li>
      <li><strong>토큰</strong> : 문법적인 의미를 가지면서 문법적으로 더 이상 나눌 수 없는 최소 단위를 의미. 연산자, 키워드, 식별자, 리터럴 등이 토큰에 해당한다.</li>
    </ul>
  </div>
</details>
<br/>