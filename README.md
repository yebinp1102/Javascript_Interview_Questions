<div align="center">
  <h2> [ 자바스크립트 면접 기출 문제 정리 ] </h2>
  <p style="color:gray">문제 클릭시 답변이 등장 합니다.</p>
</div>
<hr/>

<!-- 문제 1 -->
<details>
  <summary>
    1. 이벤트 위임(event delegation)이란?
  </summary>
  <br/>
  <div>
    이벤트 위임은 주로 비슷한 방식으로 여러 요소에 이벤트를 할당하거나 핸들링 할 때 사용 됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않는 대신 요소의 공통 조상에만 이벤트 핸들러를 할당해도 여러 요소들을 핸들링 할 수 있습니다. 여러 요소에 이벤트를 할당하게 되면 메모리 점유율이 높아져 페이지 성능이 낮아진다는 단점이 있는데, 이벤트 핸들링을 이벤트 위임으로 구현하게 되면 문제를 해소할 수 있다는 장점이 있습니다.
  </div>
</details>
<br/>
<!-- 문제 2 -->
<details>
  <summary>
    2. this 키워드에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    객체의 메서드는 자신이 속한 객체의 프로퍼티를 참조하고 변경할 수 있어야 하는데, 이때 this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다. 구체적으로 this란 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 이며, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정 됩니다. <br/><br/>
    1. 객체 리터럴로 생성된 객체의 내부 this : 메서드를 호출한 객체가 바인딩 됩니다. <br/><br/>
    2. 생성자 함수로 생성된 객체 내부 this : 생성자 함수가 생성할 인스턴스가 바인딩 됩니다. <br/><br/>
    3. 전역에서 this와 일반 함수 내부의 this에는 window가 디폴트로 바인딩 되며, use strict 모드에서는 undefined가 바인딩 됩니다. <br/><br/>
    4. Function.prototype.apply/call 메서드에 의한 간접 호출시 this : apply와 call 메서드의 본질적인 기능은 함수를 호출하면서 인수로 전달한 객체를 해당 함수의 this에 바인딩 하므로, this에는 메서드의 인수로 전달한 특정 객체가 바인딩 됩니다. <br/><br/>
    5. Function.prototype.bind 메서드에 의한 간접 호출시 this : bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달하기 때문에 this에는 인수로 전달한 객체가 바인딩 됩니다.
    <br/><br/>
    <p>요약</p>
    <table border="1">
      <tr bgcolor="salmon">
        <td>함수 호출 방식</td>
        <td>this 바인딩</td>
      </tr>
      <tr>
        <td>일반 함수 호출</td>
        <td>전역 객체 window</td>
      </tr>
      <tr>
        <td>메서드 호출</td>
        <td>메서드를 호출 한 객체</td>
      </tr>
      <tr>
        <td>생성자 함수 호출</td>
        <td>생성자 함수가 미래에 생성할 인스턴스</td>
      </tr>
      <tr>
        <td>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</td>
        <td>메서드의 첫번째 인수로 전달한 객체</td>
      </tr>
    </table>
  </div>
</details>
<br/>
<!-- 문제 3 -->
<details>
  <summary>
    3. prototype 기반 상속에 대해 설명하시요.
  </summary>
  <br/>
  <div>
    프로토타입은 프로토타입 객체라고도 불리며, 인스턴스를 포함한 어떤 객체의 부모 객체 역할을 하는 객체입니다. 자바스크립트에서 어떤 객체의 프로퍼티나 메서드를 다른 객체에 공유할 때, 프로토타입을 기반으로 상속을 구현하는 것이 개발 비용 측면에서 효율적입니다. 그 이유는 하나의 메서드를 다른 객체에 공유하는 두가지 방식을 비교하면 명확히 드러나는데요. 만약 생성자 함수 내부의 메서드를 생성될 인스턴스들이 갖게 되는 상황을 고려 했을 때, 프로토타입 기반 상속을 하지 않는 경우에는 인스턴스가 생성 될 때마다 생성자 함수의 메서드가 중복 생성되어, 같은 구조의 메서드가 메모리의 여러 공간을 차지하기 때문에 매우 비효율 적입니다. 반면 프로토타입을 기반으로 메서드를 상속하게 되면, 이러한 불필요한 중복을 제거 할 수 있는데요. 생성자 함수가 기본적으로 갖는 prototype이라는 프로퍼티에 어떤 메서드를 바인딩 하게 되면 해당 생성자 함수가 생성한 모든 인스턴스가 하나의 메서드를 공유해서 사용하기 떄문에 하나의 메모리 공간만 차지하게 됩니다. 
    <br/><br/>
    예시 코드와 함께 더 자세한 설명이 궁금하다면 제 블로그를 방문해주세요. <br/>
    <a href="https://blog.naver.com/yebinp1102/222886852128">블로그 링크 : https://blog.naver.com/yebinp1102/222886852128</a>
  </div>
</details>
<br/>
<!-- 문제 4 -->
<details>
  <summary>
    4. null과 undefined 그리고 undeclared에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    ◎ null은 변수에 값이 없다는 것을 <strong>"의도적으로 명시"</strong> 할 때 사용하는 자바스크립트의 데이터 타입 중 하나 입니다. 일반적으로 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하기 위해 사용하며, 변수에 null을 할당하게 되면 JS엔진은 아무도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행하기 됩니다.
    <br/>
    <br/>
    ◎ undefined는 JS 엔진이 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄지기 전까지 빈 상태로 두지 않기 위해 할당하는 초기 값 입니다. 이러한 이유로 var 키워드로 변수 선언 후 값을 할당 하지 않은 상태로 변수를 호출하면 undefined가 출력 됩니다. 
    <br/>
    <br/>
    ◎ undeclared는 접근 가능한 스코프에 변수 선언이 되지 않은 상태를 의미합니다. undeclared 상태의 변수를 참조 하게 되면 Uncaught ReferenceError 에러가 해당 함수가 정의 되지 않은 상태라는 메세지를 출력하게 됩니다.
  </div>
</details>
<br/>
<!-- 문제 5 -->
<details>
  <summary>
    5. 다음 코드가 즉시 호출 함수 표현식(IIFE)로 동작하지 않는 이유에 관해서 설명해보세요: function foo(){ }();.
  </summary>
  <br/>
  <div>
    즉시 실행 함수의 기본 형태는 그룹 연산자 (...)로 함수를 감싸고 있어야 하며, 함수의 코드 블럭 뒤에너느 함수 호출 연산자()가 있어야 한다. 하지만 위의 코드에서는 그룹 연산자로 감싸지 않았기 때문에 즉시 실행 함수로 동작하지 않는다. 더 구체적으로 이야기하자면 JS 엔진은 호출 연산자 ()를 함수와 분리된 그룹 연산자로 인식하기 때문에 function foo(){}; ()로 이해 하는 것이다. 이렇게 피연산자가 없는 그룹 연산자는 문법 에러를 발생시킨다. 만약 주어진 코드를 즉시 실행 함수로 동작하게 하고 싶다면, 아래와 같이 작성해야 한다. <br/>
    <code>(function foo(){ }())</code>
  </div>
</details>
<br/>
<!-- 문제 6 -->
<details>
  <summary>
    6. 익명함수(anonymous functions)는 주로 어떤 상황에서 사용하나요?
  </summary>
  <br/>
  <div>
    일반적으로 함수는 재사용을 위해 일단 선언 해두고 필요할 때마다 호출해서 쓰기 때문에 호출에 대비해 항상 메모리 공간의 일부를 차지합니다. 그런데 만약 어떤 함수가 한번만 사용된다면, 메모리 관리 측면에서 더 이상 필요없는 함수가 메모리 공간을 차지하는 것은 비효율적입니다. 이러한 경우에 사용하는 것이 바로 "익명 함수"인데요. 익명 함수는 자신이 호출 될때만 일시적으로 메모리 공간에 존재하다가 함수의 생명 주기가 끝나면 가비지 컬렉터에 의해 삭제되기 때문에 메모리 관리 측면에서 효율적입니다. 이러한 특징 때문에 익명 함수는 주로 state가 의도치 않게 변경되는 것을 방지하는 '클로져'나 '콜백 함수'로 사용 됩니다.
  </div>
</details>
<br/>
<!-- 문제 7 -->
<details>
  <summary>
    7. 클로져(Closure)는 무엇이며 왜 사용하나요?
  </summary>
  <br/>
  <div>
    외부 함수보다 중첩 함수의 생명 주기가 더 긴 경우에 중첩 함수가 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 때가 있는데, 이때 이 중첩 함수를 클로져라고 부른다. 예를 들어 전역에 선언된 inside라는 함수가 콘솔 창에 변수 x의 값을 출력하고, 전역에 선언된 outside 라는 함수가 변수 x의 값을 갖고 있고 inside 함수를 호출 한다고 가정해보자. 코드로 나타내면 아래와 같다.</br>
    <code>
      function outside(){</br>
      &nbsp const x = 10;</br>
      &nbsp inside()</br>
      }</br>
      function inside(){</br>
      &nbsp console.log(x)</br>
      }</br>
      outside()
    </code>
    <br/>
    이때 inside 함수가 클로져가 되는 것이다. 그 이유는 outside 함수가 호출 되면서 실행 컨텍스트에 push 되어 함수 코드 블럭의 코드를 하나씩 실행 하다가 마지막으로 inside 함수를 호출하면서 종료되기 때문에 실행 컨텍스트에서 pop 된다. 이는 outside 함수의 생명 주기가 종료 되었음을 의미하며, outside 함수의 생명 주기가 종료된 시점에 inside 함수가 실행 중이라면 inside 함수는 outside 함수보다 생명 주기도 길면서 상위 스코프에서 x 값을 참조하기 때문에 클로져가 되는 것이다.
    <br/>
    이러한 클로져는 주로 상태(state)가 의도하지 않은 방향으로 변경되는 것을 방지하기 위해 은닉하거나 특정 함수에게만 상태 변경을 허용하기 위해 사용된다.  
  </div>
</details>
<br/>
<!-- 문제 8 -->
<details>
  <summary>
    8. 아래 3개의 코드들의 차이점을 설명하시오.
    <br/><br/>
    <code>
      fucntion Person(){}; <br/>
      var person = Person(); <br/>
      var person = new Person(); <br/>
    </code>
  </summary>
  <br/>
  <div>
    먼저 <code>function Person(){};</code>은 일반 함수 선언문으로 실행을 하기 위해서는 호출을 해야만 한다. 반면 <code>var person = Person();</code>은 선언된 Person 함수를 호출하고, Person 함수가 반환하는 값을 person 변수에 할당한다. 그리고 <code>var person = new Person();</code>는 Person 생성자 함수가 만든 인스턴스를 person 변수에 할당한다. 참고로 Person 생성자 함수가 생성한 인스턴스는 Person 객체의 인스턴스를 상속 받는다. 
  </div>
</details>
<br/>
<!-- 문제 9 -->
<details>
  <summary>
    9. call과 apply 메서드의 차이는 무엇인가.
  </summary>
  <br/>
  <div>
    call과 apply 메서드가 공통적으로 하는 역할은 크게 2개이다. 첫번째는 첫번째 인수로 전달 받은 값을 함수의 this에 바인딩 하는 것이고, 두번째는 두번째 인수로 전달받은 데이터를 함수의 인수로 전달하면서 함수를 호출 하는 것이다. 함수 내부의 this에 특정 값을 명시적으로 바인딩 하면서 함수를 호출하며 동작 방식이 똑같지만 함수 호출 시 해당 함수에 인수를 전달하는 방식이 다르다. call 메서드는 함수 호출 시 전달할 인수들을 구분할 때 쉼표를 사용하지만, apply 메서드는 인수들을 하나의 배열로 묶어서 전달한다. <br><br>
    - 코드 예시<br>
    <code>
    function foo(a ,b, c){ <br>
    &nbsp console.log(‘’,arguments) <br>
    &nbsp return a+b+c; <br>
    } <br>
    let this = {a : 1} <br>
    foo.apply(this, [1, 2, 3]); <br>
    Foo.call(this, 1, 2, 3); 
    </code>
  </div>
</details>
<br/>
<!-- 문제 10 -->
<details>
  <summary>
    10. bind 메서드에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    bind 메서드도 call, apply 메서드와 this 바인딩을 위해서 사용되지만, 두 메서드와 달리 함수를 호출하지 않고 그저 인수로 받은 값을 해당 객체의 this에 바인딩한다. 이러한 bind 메서드는 주로 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 일치하지 않는 경우 통일 하기 위해 사용된다.
  </div>
</details>
<br/>
<!-- 문제 11 -->
<details>
  <summary>
    11. document.write()는 언제 사용하나요?
  </summary>
  <br/>
  <div>
    document 객체의 메서드인 write는 인수로 전달 받은 값을 웹 브라우저에 출력합니다. write 메서드는 웹 페이지 로딩 후 가장 먼저 인수로 전달받은 데이터를 브라우저에 출력하는데요. 이때 브라우저에 이미 로딜 된 데이터를 지우고 해당 데이터만 출력하므로 주로 디버깅이나 연산 결과를 확인 할 때 사용됩니다.
  </div>
</details>
<br/>
<!-- 문제 12 -->
<details>
  <summary>
    12. AJAX란 무엇인가요? AJAX의 장단점도 설명하시오.
  </summary>
  <br/>
  <div>
    AJAX란 자바스크립트로 브라우저가 서버에게 비동기 방식의 데이터를 요청하고, 서버가 응답한 데이터를 수신해서 동적으로 갱신하는 프로그래밍 방식입니다. AJAX는 브라우저가 제공하는 Web API인 XMLHttpRequest 객체를 기반으로 동작하는데, 참고로 이 XMLHttpRequest 객체는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공합니다. AJAX의 장단점은 아래와 같습니다. <br><br>
    <장점><br>
    1. 브라우저의 일부만 변경해야 할 경우 필요한 데이터만 서버로부터 전송 받기 때문에 불필요한 데이터 통신이 발생하지 않는다. <br>
    2. 변경되지 않은 부분은 리렌더링 되지 않기 떄문에 화면 깜빡임 현상도 현저히 줄어든다. <br>
    3. 클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에 요청을 보내도 응답을 받을 때까지 다음 코드를 실행하지 않는 블로킹 현상이 발생하지 않는다.<br><br>
    <단점><br>
    1. XMLHttpRequest를 통해 통신 할 때, 사용자에게 아무런 정보를 주지 않는다.<br>
    2. AJAX를 지원하지 않는 브라우저가 존재한다.<br>
    3. 히스토리 관리가 어렵다.<br>
    4. 페이지 이동 없이 통신하기 때문에 보안에 취약하다.<br>
  </div>
</details>
<br/>
<!-- 문제 13 -->
<details>
  <summary>
    13. JSON은 어떻게 동작하나요?
  </summary>
  <br/>
  <div>
    JSON이란 클라이언트와 서버간의 HTTP 통신을 위해 주고 받는 데이터 형식으로 key와 value로 구성된 텍스트 데이터 포맷입니다. 만약 클라이언트 측에서 서버에게 어떤 데이터를 전송해야 한다면, JSON의 stringify 메서드를 사용해서 반드시 객체를 JSON 포맷의 문자열로 반환 해야 합니다. 반면 서버측에서 클라이언트에게 어떤 데이터를 전송할 경우에는 JSON의 parse 메서드를 사용해서 JSON 포맷의 문자열을 객체화 해야 합니다.
  </div>
</details>
<br/>
<!-- 문제 14 -->
<details>
  <summary>
    14. JSON과 AJAX는 어떻게 다른가?
  </summary>
  <br/>
  <div>
    JSON은 클라이언트와 서버가 통신을 위해 주고 받는 데이터의 포맷 형식입니다. 이와 달리 AJAX는 클라이언트와 서버가 통신해서 XMLHttpRequest 객체를 이용해서 브라우저의 일부만 리렌더링 하기 위한 비동기 통신 방법입니다. 
  </div>
</details>
<br/>
<!-- 문제 15 -->
<details>
  <summary>
    15. 호이스팅이란? (변수 호이스팅과 함수 호이스팅의 차이)
  </summary>
  <br/>
  <div>
    JS엔진은 런타임 이전에 모든 선언문을 먼저 실행합니다. 때문에 선언문 이전에 함수나 var 키워드로 선언된 변수가 참조 가능합니다. 이렇게 코드가 마치 선두에 있는 것처럼 동작하는 자바스크립트 고유의 특징이 바로 호이스팅 입니다. 참고로 변수 호이스팅과 함수 호이스팅은 조금 다르게 동작합니다. var 키워드로 선언된 변수는 변수 선언문 이전에 참조하게 되면 undefined로 평가되는 반면, 함수 선언문 이전에 함수를 참조하게 되면 멀쩡하게 호출 됩니다. 그 이유는 var 키워드로 선언된 변수의 경우 런타임 이전에 식별자에 undefined가 할당 되는 반면 함수 선언문으로 선언된 변수의 경우 런타임 이전에 함수 객체가 생성되고, JS엔진이 함수명과 동일한 식별자를 암묵적으로 생성해서 생성된 함수 객체를 그 식별자에 할당합니다. 이러한 이유로 함수 선언문 이전에 함수 호출이 가능한 것입니다. 
  </div>
</details>
<br/>
<!-- 문제 16 -->
<details>
  <summary>
    16. 이벤트 버블링이란?
  </summary>
  <br/>
  <div>
    어떤 DOM 요소 노드에서 이벤트가 발생하면, 이 요소에 할당된 이벤트 핸들러가 동작한다. 그 후 이어서 부모 요소 노드의 이벤트 핸들러가 수행되고, 이후 부모의 부모 요소의 이벤트 핸들러가 수행 된다. 이러한 과정은 최상단의 요소 노드에 도달 할 때까지 반복되며, 이렇게 이벤트 핸들러가 상위 요소로 전파되는 현상을 이벤트 버블링이라고 한다. 예를 들어 form 태그 내부에 div 태그가 있고, div 태그 내부에 p태그가 있으며, 각 태그를 클릭할 경우 alert 창에 어떤 태그에서 이벤트가 발생 했는지 알리는 코드가 있다고 가정해보자. 만약 가장 하위에 있는 p태그를 클릭하면 alert 창에는 p가 출력된다. 그리고 alert 창을 닫으면 곧바로 또 다른 alert 창에 div가 출력되고, 다시 창을 끄면 form을 출력하는 alert태그가 출력된다.
  </div>
</details>
<br/>
<!-- 문제 17 -->
<details>
  <summary>
    17. 이벤트 캡쳐링이란?
  </summary>
  <br/>
  <div>
    이벤트 버블링과 반대로 어떤 태그에 이벤트 발생 시 이벤트 핸들러가 하위 요소로 전파되는 현상.
  </div>
</details>
<br/>
<!-- 문제 18 -->
<details>
  <summary>
    18. 속성(attribute)과 요소(element)의 차이는?
  </summary>
  <br/>
  <div>
    요소란 HTML 문서를 구성하는 각 태그를 의미하며, 속성이란 이러한 요소들의 동작을 제어하기 위한 추가 정보를 제공 합니다. 예를 들어 a 태그에 클릭시 이동할 주소를 가리키는 href 값이 있을 때, 요소는 a이며 href는 속성입니다.
  </div>
</details>
<br/>
<!-- 문제 19 -->
<details>
  <summary>
    19. 비교 연산자 ==와 ===의 차이는?
  </summary>
  <br/>
  <div>
    동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 암묵적으로 타입을 일치 시킨 후 같은 값인 지 판별합니다. 반면 일치 비교 연산자(===)는 좌항광 우항의 피연산자가 타입도 일치하고 값도 일치하는 경우에만 true를 반환합니다.
  </div>
</details>
<br/>
<!-- 문제 20 -->
<details>
  <summary>
    20. duplicate([1,2,3,4,5])의 결과가 [1,2,3,4,5,1,2,3,4,5]가 되도록 코드를 작성하시오.
  </summary>
  <br/>
  <code>
    function duplicate(arr){<br>
      return [...arr, ...arr]<br>
    }
  </code>
</details>
<br/>
<!-- 문제 21 -->
<details>
  <summary>
    21. 삼항식을 사용하는 이유는 무엇이며 어떻게 사용하나요?
  </summary>
  <br/>
  <div>
    삼항식은 조건식의 평가 결과에 따라 반환 값을 결정하는 문입니다. 삼항식은 총 3개의 피연산자를 갖는데요. 첫번째 피연산자는 조건식으로 true나 false로 평가되며, true로 평가될 경우 두번째 피연산자를 반환하는 반면 false로 평가될 경우 세번째 피연산자를 반환합니다. if...else문과 비교 했을 때, if...else문은 표현식이 아니기 때문에 반환 값을 값처럼 사용할 수 없는 반면, 삼항식은 값으로 평가 가능한 표현식인 문이기 때문에 반환 값을 값으로 사용 가능합니다. 이러한 특징 때문에 조건이 1개이며 조건에 따라 결정되는 값을 변수에 할당 하고 싶은 경우에 if...else문 보다 삼항식을 사용하는 것이 훨씬 유리합니다. 
  </div>
</details>
<br/>
<!-- 문제 22 -->
<details>
  <summary>
    22. use strict란 무엇인가요?
  </summary>
  <br/>
  <div>
    use strict는 자바스크립트에서 허용하는 애매한 문법을 모두 오류라고 인식하기 때문에 프로그래밍의 흐릅에 더 적합하고 정확한 코드를 작성하기 위해 사용됩니다. use strict를 사용하려면 적용하려는 스코프의 최상단에 작성하면 됩니다. 만약 use strict가 선언되지 않은 상태에서 함수 선언 키워드(var, let, cont) 없이 선언된 변수를 참조 할 경우, JS엔진이 암묵적으로 변수 선언문으로 인식하기 때문에 변수 참조가 가능하다. 하지만 엄격하게 문법적으로 그리고 프로그래밍의 흐름에 부적합하다. 이러한 문제를 해결 하기 위해 해당 변수의 스코프 최상단에 use strict를 작성하면 정석으로 선언되지 않은 변수 참조시 에러가 발생하기 된다. 이렇게 use strict를 사용할 경우 안전한 코드 작성이 가능하고 JS 엔진이 자동으로 최적화하여 연산을 수행하기 때문에 수행 속도가 더 빨라진다는 장점이 있다. 

  </div>
</details>
<br/>
<!-- 문제 23 -->
<details>
  <summary>
    23. 전역 스코프(scope)의 장단점은 무엇인가요?
  </summary>
  <br/>
  <div>
    전역 스코프에 선언된 변수나 함수는 하위의 어떤 스코프에서든 접근 가능하다는 장점이 있다. 하지만 모든 스코프에서 접근 가능하기 때문에 의도하지 않은 값 변경이 발생 할 수 있으며, 이러한 문제가 발생할 경우 어느 스코프에서 값을 변경 했는지 추적하기 어려울 수 있다. 또한 전역 스코프에 선언된 변수와 함수의 생명 주기는 어플리케이션이 실행되는 순간부터 종료되는 순간이기 때문에 더이상 참조 되지 않는 변수 혹은 함수라 해도 메모리 공간을 계속해서 차지하기 때문에 메모리 낭비로 이어진다. 이외에도 변수명 중복 가능성과 스코프의 depth가 깊어질수록 전역에 선언된 변수를 검색하는 속도가 느려진다는 단점이 있기 때문에 전역에 변수를 선언할 때, 반드시 전역에 선언되지 않으면 안되는 변수인지 확인하고 그렇지 않은 경우 지역 변수로 선언하는 것이 올바르다. 
  </div>
</details>
<br/>
<!-- 문제 24 -->
<details>
  <summary>
    24. SPA에서 SEO에 유리해지려면 어떻게 해야 하나요?
  </summary>
  <br/>
  <div>
    SPA는 기본적으로 CSR 방식으로 구현되기 때문에 SEO에 불리 할 수 밖에 없다. SPA는 클라이언트가 여러 페이지를 하나의 페이지에 구현하기 때문에 JS를 읽지 못하는 검색 엔진은 해당 페이지의 HTML 문서에서 중요한 데이터들을 추출하지 못한다. 즉 크롤링에 불리하다. 이러한 문제를 해결하기 위한 방법은 크게 3가지로 나뉜다. 첫번째는 CSR 대신 SSR을 채택하는 것이고, 두번째는 동적 렌더링을 사용하는 것이며, 세번째는 History API를 사용하는 것이다. 동적 렌더링이란 SSR 사용이 불가피한 경우 주로 사용하는 방식으로 서버에서 요청하는 자가 사람인지 크롤러인지 판단 후, 사람이면 HTML과 JS 문서를 제공하고 크롤러이면 렌더링된 HTML 버전의 페이지를 제공해서 크롤링 가능하게 하는 방법이다. History API는 SPA 어플리케이션의 한 페이지에서 일부 컨텐츠만 변경될 경우 url 변경이 없어 크롤링이 되지 않는 문제 해결을 위해 일부 컨텐츠 변경시 url이 변경되도록 하는 방법이다.
  </div>
</details>
<br/>