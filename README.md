<div align="center">
  <h2> [ 자바스크립트 면접 기출 문제 정리 ] </h2>
  <p style="color:gray">문제 클릭시 답변이 등장 합니다.</p>
</div>
<hr/>

<!-- 문제 1 -->
<details>
  <summary>
    1. 이벤트 위임(event delegation)이란?
  </summary>
  <br/>
  <div>
    이벤트 위임은 주로 비슷한 방식으로 여러 요소에 이벤트를 할당하거나 핸들링 할 때 사용 됩니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않는 대신 요소의 공통 조상에만 이벤트 핸들러를 할당해도 여러 요소들을 핸들링 할 수 있습니다. 여러 요소에 이벤트를 할당하게 되면 메모리 점유율이 높아져 페이지 성능이 낮아진다는 단점이 있는데, 이벤트 핸들링을 이벤트 위임으로 구현하게 되면 문제를 해소할 수 있다는 장점이 있습니다.
  </div>
</details>
<br/>
<!-- 문제 2 -->
<details>
  <summary>
    2. this 키워드에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    객체의 메서드는 자신이 속한 객체의 프로퍼티를 참조하고 변경할 수 있어야 하는데, 이때 this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다. 구체적으로 this란 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 이며, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정 됩니다. <br/><br/>
    1. 객체 리터럴로 생성된 객체의 내부 this : 메서드를 호출한 객체가 바인딩 됩니다. <br/><br/>
    2. 생성자 함수로 생성된 객체 내부 this : 생성자 함수가 생성할 인스턴스가 바인딩 됩니다. <br/><br/>
    3. 전역에서 this와 일반 함수 내부의 this에는 window가 디폴트로 바인딩 되며, use strict 모드에서는 undefined가 바인딩 됩니다. <br/><br/>
    4. Function.prototype.apply/call 메서드에 의한 간접 호출시 this : apply와 call 메서드의 본질적인 기능은 함수를 호출하면서 인수로 전달한 객체를 해당 함수의 this에 바인딩 하므로, this에는 메서드의 인수로 전달한 특정 객체가 바인딩 됩니다. <br/><br/>
    5. Function.prototype.bind 메서드에 의한 간접 호출시 this : bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달하기 때문에 this에는 인수로 전달한 객체가 바인딩 됩니다.
    <br/><br/>
    <p>요약</p>
    <table border="1">
      <tr bgcolor="salmon">
        <td>함수 호출 방식</td>
        <td>this 바인딩</td>
      </tr>
      <tr>
        <td>일반 함수 호출</td>
        <td>전역 객체 window</td>
      </tr>
      <tr>
        <td>메서드 호출</td>
        <td>메서드를 호출 한 객체</td>
      </tr>
      <tr>
        <td>생성자 함수 호출</td>
        <td>생성자 함수가 미래에 생성할 인스턴스</td>
      </tr>
      <tr>
        <td>Function.prototype.apply/call/bind 메서드에 의한 간접 호출</td>
        <td>메서드의 첫번째 인수로 전달한 객체</td>
      </tr>
    </table>
  </div>
</details>
<br/>
<!-- 문제 3 -->
<details>
  <summary>
    3. prototype 기반 상속에 대해 설명하시요.
  </summary>
  <br/>
  <div>
    프로토타입은 프로토타입 객체라고도 불리며, 인스턴스를 포함한 어떤 객체의 부모 객체 역할을 하는 객체입니다. 자바스크립트에서 어떤 객체의 프로퍼티나 메서드를 다른 객체에 공유할 때, 프로토타입을 기반으로 상속을 구현하는 것이 개발 비용 측면에서 효율적입니다. 그 이유는 하나의 메서드를 다른 객체에 공유하는 두가지 방식을 비교하면 명확히 드러나는데요. 만약 생성자 함수 내부의 메서드를 생성될 인스턴스들이 갖게 되는 상황을 고려 했을 때, 프로토타입 기반 상속을 하지 않는 경우에는 인스턴스가 생성 될 때마다 생성자 함수의 메서드가 중복 생성되어, 같은 구조의 메서드가 메모리의 여러 공간을 차지하기 때문에 매우 비효율 적입니다. 반면 프로토타입을 기반으로 메서드를 상속하게 되면, 이러한 불필요한 중복을 제거 할 수 있는데요. 생성자 함수가 기본적으로 갖는 prototype이라는 프로퍼티에 어떤 메서드를 바인딩 하게 되면 해당 생성자 함수가 생성한 모든 인스턴스가 하나의 메서드를 공유해서 사용하기 떄문에 하나의 메모리 공간만 차지하게 됩니다. 
    <br/><br/>
    예시 코드와 함께 더 자세한 설명이 궁금하다면 제 블로그를 방문해주세요. <br/>
    <a href="https://blog.naver.com/yebinp1102/222886852128">블로그 링크 : https://blog.naver.com/yebinp1102/222886852128</a>
  </div>
</details>
<br/>
<!-- 문제 4 -->
<!-- 문제3 -->
<details>
  <summary>
    4. null과 undefined 그리고 undeclared에 대해 설명하시오.
  </summary>
  <br/>
  <div>
    ◎ null은 변수에 값이 없다는 것을 <strong>"의도적으로 명시"</strong> 할 때 사용하는 자바스크립트의 데이터 타입 중 하나 입니다. 일반적으로 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하기 위해 사용하며, 변수에 null을 할당하게 되면 JS엔진은 아무도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행하기 됩니다.
    <br/>
    <br/>
    ◎ undefined는 JS 엔진이 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄지기 전까지 빈 상태로 두지 않기 위해 할당하는 초기 값 입니다. 이러한 이유로 var 키워드로 변수 선언 후 값을 할당 하지 않은 상태로 변수를 호출하면 undefined가 출력 됩니다. 
    <br/>
    <br/>
    ◎ undeclared는 접근 가능한 스코프에 변수 선언이 되지 않은 상태를 의미합니다. undeclared 상태의 변수를 참조 하게 되면 Uncaught ReferenceError 에러가 해당 함수가 정의 되지 않은 상태라는 메세지를 출력하게 됩니다.
  </div>
</details>
<br/>